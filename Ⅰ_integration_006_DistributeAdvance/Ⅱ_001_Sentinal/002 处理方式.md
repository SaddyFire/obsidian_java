## 01 流控/限流

限制同一时间段访问的QPS



### 1.1 簇点链路

当请求进入微服务时，首先会访问DispatcherServlet，然后进入Controller、Service、Mapper，这样的一个调用链就叫做**簇点链路**。簇点链路中被监控的每一个接口就是一个**资源**。

默认情况下sentinel会监控SpringMVC的每一个端点（Endpoint，也就是controller中的方法），因此SpringMVC的每一个端点（Endpoint）就是调用链路中的一个资源。

### 1.2 流控模式
##### 1. 直接：统计当前资源的请求，触发阈值时对当前资源直接限流，也是默认的模式
![[Pasted image 20220115203436.png]]
##### 2. 关联：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流
![[Pasted image 20220115210314.png]]
![[Pasted image 20220115210339.png]]

**语法说明**：当/write资源访问量触发阈值时，就会对/read资源限流，避免影响/write资源。

**使用场景**：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是优先支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流。

**需求说明**：

-   在OrderController新建两个端点：/order/query和/order/update，无需实现业务
-   配置流控规则，当/order/ update资源被访问的QPS超过5时，对/order/query请求限流

##### 3. 链路：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流

**链路模式**：只针对从指定链路访问到本资源的请求做统计，判断是否超过阈值。

**配置示例**：

例如有两条请求链路：

-   /test1 --> /common
-   /test2 --> /common

`order-server服务.OrderService`

```java
public void queryGoods(){
    System.err.println("查询商品");
}
```

`order-service服务.OrderController`
```java
@GetMapping("/query")
public String queryOrder() {
    // 查询商品
    orderService.queryGoods();
    // 查询订单
    System.out.println("查询订单");
    return "查询订单成功";
}
```

`order-service服务.OrderController`
```java
@GetMapping("/save")
public String saveOrder() {
    // 查询商品
    orderService.queryGoods();
    // 查询订单
    System.err.println("新增订单");
    return "新增订单成功";
}
```

`order-service服务.OrderService`
添加注解
```java
@SentinelResource("goods")
public void queryGoods(){
    System.err.println("查询商品");
}
```

链路模式中，是对不同来源的两个链路做监控。但是sentinel默认会给进入SpringMVC的所有请求设置同一个root资源，会导致链路模式失效。

我们需要关闭这种对SpringMVC的资源聚合，修改order-service服务的application.yml文件：

`ordier-service服务.application.yml`
**注意缩进**
```yml
spring:
  cloud:
    sentinel:
      web-context-unify: false # 关闭context整合
```

![[Pasted image 20220116175342.png]]

限制


## 02 降级


## 03 隔离


## 04 熔断




