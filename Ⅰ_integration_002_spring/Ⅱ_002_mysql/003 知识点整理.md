OLAP -> 联机分析处理 -> 对历史数据的分析, 产生决策影响
OLTP -> 联机事务处理 -> 必须要在很短的时间内反馈结果

索引的创建跟存储引擎是挂钩的? -> 存储引擎标识不同的数据在磁盘的不同组织形式

聚簇索引/ 非聚簇索引

是否是局促索引取决于数据跟索引是否是放在一起的

innodb -> 只能有一个是聚簇索引 -> 向innodb插入数据的时候, 必须要包含一个索引的key值 -> 这个索引的key值, 可以是主键, 如果没有主键, 那么就是唯一键, 如果没有唯一键, 那么就是一个自生成的6字节的rowid

1. mysql表中有几个索引? -> 至少一个,可以是主键, 也可以是唯一键, 没有则为rowid
2. 回表 -> select \* from table where name = zhangsan 当根据普通索引查询到聚簇索引的key值之后, 再根据key值再聚簇索引中获取所有行记录
3. 索引覆盖 -> select id, name from table where name=zhangsan 根据name可以直接查询到id, name两列的值, 直接返回即可, 不需要从聚簇索引查询任何数据, 此时叫做索引覆盖(id是聚簇索引,name是索引列)
4. 最左匹配(组合索引)

select \* from table where name = ? and age =? 用
select \* from table where name = ?  用
select \* from table where age =? 不用
select \* from table where age =? and name = ? 用

5. 索引下推 -> select \* from bable where name=? and age=?
在没有索引下推之前: 先根据name从存储引擎中获取符合规则的数据, 然后再servercent对age 进行过滤
有索引下推之后: 根据name, age两个的条件来从存储引擎中获取对应的数据

磁盘预读: 磁盘跟内存进行交互的最小逻辑单元, 一般都是跟操作系统相关的

binlog -> mysql server
redo log -> innodb
indo log -> innodb


索引优化:
1. 当使用索引进行查询的时候尽量不要使用表达式, 把计算放到业务层而不是数据层
	- `explain select actor_id form actor where actor_id+1=5`
	- `explain select actor_id from actor where actor_id=4`
2. 尽量使用主键查询, 而不是其他索引, 因此主键查询不会触发
3. 使用前缀索引
4. 使用索引扫描来排序
5. union all, in , or 都能够使用索引, 推荐使用in
	- `select * from actor where actor_id = 1 union all select * from actor where actor_id =2`
	- `select * from actor where actor_id in (1,2)`
	- `explain * from actor where actor_id = 1 or actor = 2`
5. 范围列可以用到索引
	- 范围条件是: <  <=  >  >=  between
	- 范围列可以用到索引. 但是范围列后面的列无法用到索引, 索引最多用于一个范围列



left join / right join / inner join  左连接显示左边全部数据和右表连接数据
union all / union  去重?


平时注意: 
1. 

