/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
__export(exports, {
  default: () => CopyUrlInPreview
});
var import_obsidian = __toModule(require("obsidian"));

// src/helpers.ts
var loadImageBlobTimeout = 5e3;
function withTimeout(ms, promise) {
  const timeout = new Promise((resolve, reject) => {
    const id = setTimeout(() => {
      clearTimeout(id);
      reject(`timed out after ${ms} ms`);
    }, ms);
  });
  return Promise.race([
    promise,
    timeout
  ]);
}
function loadImageBlob(imgSrc) {
  return __async(this, null, function* () {
    const loadImageBlobCore = () => {
      return new Promise((resolve, reject) => {
        const image = new Image();
        image.crossOrigin = "anonymous";
        image.onload = () => {
          const canvas = document.createElement("canvas");
          canvas.width = image.width;
          canvas.height = image.height;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(image, 0, 0);
          canvas.toBlob((blob) => {
            resolve(blob);
          });
        };
        image.onerror = () => __async(this, null, function* () {
          try {
            yield fetch(image.src, { "mode": "no-cors" });
            const blob = yield loadImageBlob(`https://api.allorigins.win/raw?url=${encodeURIComponent(imgSrc)}`);
            resolve(blob);
          } catch (e) {
            reject();
          }
        });
        image.src = imgSrc;
      });
    };
    return withTimeout(loadImageBlobTimeout, loadImageBlobCore());
  });
}
function onElement(el, event, selector, listener, options) {
  el.on(event, selector, listener, options);
  return () => el.off(event, selector, listener, options);
}

// src/main.ts
var IMAGE_URL_PREFIX = "/_capacitor_file_";
var SUCCESS_NOTICE_TIMEOUT = 1800;
var longTapTimeout = 500;
var deleteTempFileTimeout = 6e4;
var CopyUrlInPreview = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.longTapTimeoutId = null;
  }
  onload() {
    this.register(onElement(document, "contextmenu", "a.external-link", this.onClick.bind(this)));
    if (import_obsidian.Platform.isDesktop) {
      this.register(onElement(document, "contextmenu", "img", this.onClick.bind(this)));
    } else {
      this.register(onElement(document, "touchstart", "img", this.startWaitingForLongTap.bind(this)));
      this.register(onElement(document, "touchend", "img", this.stopWaitingForLongTap.bind(this)));
      this.register(onElement(document, "touchmove", "img", this.stopWaitingForLongTap.bind(this)));
    }
  }
  startWaitingForLongTap(event, img) {
    if (this.longTapTimeoutId) {
      clearTimeout(this.longTapTimeoutId);
      this.longTapTimeoutId = null;
    } else {
      if (event.targetTouches.length == 1) {
        this.longTapTimeoutId = window.setTimeout(this.processLongTap.bind(this, event, img), longTapTimeout);
      }
    }
  }
  stopWaitingForLongTap() {
    if (this.longTapTimeoutId) {
      clearTimeout(this.longTapTimeoutId);
      this.longTapTimeoutId = null;
    }
  }
  processLongTap(event, img) {
    return __async(this, null, function* () {
      event.stopPropagation();
      this.longTapTimeoutId = null;
      const adapter = this.app.vault.adapter;
      const electronWindow = window;
      const basePath = adapter.getFullPath("");
      const webviewServerUrl = electronWindow.WEBVIEW_SERVER_URL;
      const localImagePrefixUrl = webviewServerUrl + IMAGE_URL_PREFIX + basePath;
      if (img.src.startsWith(localImagePrefixUrl)) {
        const encodedImageFileRelativePath = img.src.replace(localImagePrefixUrl, "");
        const imageFileRelativePath = decodeURIComponent(encodedImageFileRelativePath);
        yield adapter.open(imageFileRelativePath);
      } else {
        try {
          const blob = yield loadImageBlob(img.src);
          if (!blob.type.startsWith("image/")) {
            new import_obsidian.Notice(`Unsupported mime type ${blob.type}`);
            return;
          }
          const extension = blob.type.replace("image/", "");
          const randomGuid = window.URL.createObjectURL(new Blob([])).split("/").pop();
          const tempFileName = `/.temp-${randomGuid}.${extension}`;
          const buffer = yield blob.arrayBuffer();
          yield adapter.writeBinary(tempFileName, buffer);
          setTimeout(() => adapter.remove(tempFileName), deleteTempFileTimeout);
          new import_obsidian.Notice("Image was temporarily saved and will be removed in 1 minute");
          yield adapter.open(tempFileName);
        } catch (e) {
          new import_obsidian.Notice("Cannot open image");
        }
      }
    });
  }
  onClick(event) {
    event.preventDefault();
    const target = event.target;
    const imgType = target.localName;
    const menu = new import_obsidian.Menu(this.app);
    switch (imgType) {
      case "img": {
        const image = target.currentSrc;
        const thisURL = new URL(image);
        const Proto = thisURL.protocol;
        switch (Proto) {
          case "app:":
          case "data:":
          case "http:":
          case "https:":
            menu.addItem((item) => item.setIcon("image-file").setTitle("Copy image to clipboard").onClick(() => __async(this, null, function* () {
              try {
                const blob = yield loadImageBlob(image);
                const data = new ClipboardItem({ [blob.type]: blob });
                yield navigator.clipboard.write([data]);
                new import_obsidian.Notice("Image copied to the clipboard!", SUCCESS_NOTICE_TIMEOUT);
              } catch (e) {
                new import_obsidian.Notice("Error, could not copy the image!");
              }
            })));
            break;
          default:
            new import_obsidian.Notice(`no handler for ${Proto} protocol`);
            return;
        }
        break;
      }
      case "a": {
        const link = target.href;
        menu.addItem((item) => item.setIcon("link").setTitle("Copy URL").onClick(() => {
          navigator.clipboard.writeText(link);
          new import_obsidian.Notice("URL copied to your clipboard", SUCCESS_NOTICE_TIMEOUT);
        }));
        break;
      }
      default:
        new import_obsidian.Notice("No handler for this image type!");
        return;
    }
    menu.register(onElement(document, "keydown", "*", (e) => {
      if (e.key === "Escape") {
        e.preventDefault();
        e.stopPropagation();
        menu.hide();
      }
    }));
    menu.showAtPosition({ x: event.pageX, y: event.pageY });
    this.app.workspace.trigger("copy-url-in-preview:contextmenu", menu);
  }
};
