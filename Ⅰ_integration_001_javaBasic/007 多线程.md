
- 并行: 在同一时刻, 有多个指令在多个CPU上`同时`执行.
- 并发: 在同一时刻, 有多个指令在单个CPU上`交替`执行.
- 进程: 正在进行软件(就是操作系统正在运行的一个应用程序)
  - 独立性: 进程是一个能独立运行的基本单位, 同时也是系统分配资源和调度的独立单位
  - 动态性:  进程的实质是程序的一次执行过程, 进程是动态产生, 动态消亡的
  - 并发性: 任何进程都可以同其他进程一起并发执行
- 线程: 是进程中的单个顺序控制流, 是一条执行路径(比如:360软件中的杀毒,扫描木马,清理垃圾)
  - 单线程: 一个进程如果只有一条执行路径, 则成为单线程程序
  - 多线程:一个进程如果有多条执行路径, 则称为多线程程序

## 1.多线程的实现方案

- 方式1: run()  start()

  见`获取设置线程名称`

  

- 方式2: 实现Runnuable接口

  见`获得当前线程对象`

- 方式3: Callable和Future

```java
public class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        for (int i = 0; i < 100; i++) {
            System.out.println("跟女孩表白" + i);
        }
        //返回值就表示线程运行完毕之后的结果
        return "答应";
    }
}
-----------------------------------------------------
public class Test03 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //线程开启之后需要执行里面的call方法
        MyCallable mc = new MyCallable();

        //可以获取线程执行完毕之后的结果, 也可以作为参数传递给Thread对象
        FutureTask<String> ft = new FutureTask<>(mc);

        //创建线程对象
        Thread t1 = new Thread(ft);

        t1.start();
        //get方法一定要在线程启动之后才能获得结果
        String s = ft.get();

        System.out.println(s);
    }
}
```

## 2.线程成员方法

#### 2. 1 获取设置线程名称	setName()	getName()

```java
public class MyThread extends Thread{
    public MyThread() {
    }

    public MyThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(getName() + "@@@" + i);
        }
    }
}
----------------------------------------------------
public class Test {
    public static void main(String[] args) {
        MyThread t1 = new MyThread("小菜");
        MyThread t2 = new MyThread("小强");

//        t1.setName("小菜");
//        t2.setName("小强");
        t1.start();
        t2.start();
    }
}
```

#### 2. 2 获得当前线程对象	Thread.currentThread()

```java
public class MyRunnable implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName()+"方式实现多线程"+i);
        }
    }
}
-----------------------------------------------------
public class Test02 {
    public static void main(String[] args) {
        //创建了一个参数的对象
        MyRunnable mr = new MyRunnable();
        //创建了一个线程对象, 并把参数传递给这个线程;
        //在线程启动之后,执行的就是参数里面的run方法
        Thread t1 = new Thread(mr);
        t1.start();

        MyRunnable mr2 = new MyRunnable();
        Thread t2 = new Thread(mr2);
        t2.start();
        System.out.println(Thread.currentThread().getName());
    }
}
```

#### 2.3 线程休眠	Thread.sleep(100)

```java
public class MyRunnable implements Runnable{


    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+"---"+i);
        }
    }
}
-----------------------------------------------------
public class Test06 {
    public static void main(String[] args) throws InterruptedException {
        MyRunnable mr = new MyRunnable();

        Thread t1 = new Thread(mr);
        Thread t2 = new Thread(mr);

        t1.start();
        t2.start();
    }
}
```

#### 2.4 线程优先级	

```java
public class MyCallable implements Callable<String> {
    public MyCallable() {
    }

    @Override
    public String call() throws Exception {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName()+"---"+ i);
        }
        return "线程执行完毕";
    }
}
----------------------------------------------------
public class Test07 {
    public static void main(String[] args) {
        //线程开启之后需要执行里面的call方法
        MyCallable  mc = new MyCallable();

        FutureTask<String> ft = new FutureTask<>(mc);

        Thread t1 = new Thread(ft);
        t1.setName("飞机");
        t1.start();

        MyCallable  mc2 = new MyCallable();
        FutureTask<String> ft2 = new FutureTask<>(mc2);
        Thread t2 = new Thread(ft2);
        t2.setPriority(8);
        t2.setName("坦克");
        t2.start();


    }
}
```

#### 2.5 后台线程/守护线程

```java
public class MyThread1 extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(getName() + "---" +i);
        }
    }
}
-----------------------------------------------------
public class MyThread2 extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(getName() + "---" +i);
        }
    }
}
-----------------------------------------------------
public class Test01 {
    public static void main(String[] args) {
        MyThread1 t1 = new MyThread1();
        MyThread2 t2 = new MyThread2();
        t1.setName("女神");
        t2.setName("备胎");

        //把第二个线程设置为守护线程
        //当普通线程执行完之后, 守护线程也没有执行下去的必要
        t2.setDaemon(true);

        t1.start();
        t2.start();
    }

}
```

#### 2.6 同步代码块

```java
public class Ticket implements Runnable{
    //票的数量
    private int ticket = 100;
    private Object obj = new Object();
    @Override
    public void run() {
        while (true) {
            synchronized (obj) {
                if(ticket <= 0){
                    break;
                }
                //模拟出票时间
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()+"在卖票,还剩下"+ --ticket+"张票");
            }
        }
    }
}
-----------------------------------------------------
public class Test {
    //需求:某电影院目前正在上映国产大片, 共有100张票,
    // 而它有3个窗口卖票,请设计一个程序模拟该电影院卖票
    public static void main(String[] args) {
        Ticket ticket = new Ticket();

        Thread t1 = new Thread(ticket);
        Thread t2 = new Thread(ticket);
        Thread t3 = new Thread(ticket);

        t1.setName("窗口一");
        t2.setName("窗口二");
        t3.setName("窗口三");

        t1.start();
        t2.start();
        t3.start();
    }
}
```

- Lock锁

```java
public class Ticket implements Runnable{
    //票的数量
    private int ticket = 100;
    Lock ReentrantLock = new ReentrantLock();

    @Override
    public void run() {
        while (true) {
            //synchronized (obj) {
            try {
                ReentrantLock.lock();
                if(ticket <= 0){
                    break;
                }
                //模拟出票时间
                Thread.sleep(10);

                System.out.println(Thread.currentThread().getName()+"在卖票,还剩下"+ --ticket+"张票");
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                ReentrantLock.unlock();
            }
            //}
        }
    }
}
--------------------------------------------------
public class Test10 {
    public static void main(String[] args) {
        Ticket ticket = new Ticket();

        Thread t1 = new Thread(ticket);
        Thread t2 = new Thread(ticket);

        t1.setName("窗口一");
        t2.setName("窗口二");

        t1.start();
        t2.start();
    }
}
```

### 3. 生产者消费者模式

​	阻塞队列

```java
//模板:
	//1.while(true)死循环
	//2.sychronized 锁,锁对象要唯一
	//3.判断,共享数据是否结束,结束
	//4.判断,共享数据是否结束,没有结束
```


