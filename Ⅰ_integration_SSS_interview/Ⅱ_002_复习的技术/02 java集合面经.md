# 集合

#### 1、你了解java集合吗？

集合分为单列集合（collection）和双列集合(map)。单列集合又包括List(可重复)和Set（不可重复），List分为ArrayList和LinkedList，Set分为HashSet和TreeSet。双列集合Map分为TreeMap和HashMap。

单列集合是实现Iterable接口产成的对象，支持迭代器和增强for。

#### 1.2、你了解迭代器吗？说说迭代器。

从两方面来说，从底层原理上来说是大同小异的，底层通过hasnext()方法判断当前当前指向是否有元素，而指针一开始就会指向第一个元素。如果有，就会再执行next()方法，取出当前游标，并向后移一位；如果hasnext()方法返回为null,就说明不存在下一个元素，就会迭代结束。针对不同集合，会有一些细节不同，（比如HashMap就要考虑到红黑树里的取出顺序）。再底层则是采用C语言的指针原理。

在应用层面上，迭代器就是用来遍历的。所有的单列集合都可以使用迭代器，因为他们都继承了Iterable接口，这个接口里的Iterator方法可以返回一个Iterator对象，这个Iterator对象就是迭代器对象，底层针对不同类型的集合都写了不同的实现类，所以集合可以直接使用迭代器进行遍历查询。这种只需要提供一种方法（iterator方法）访问一个容器对象中各个元素，而又不暴露该对象的内部细节的方式就是迭代器设计模式。

但要注意的是，如果用的是直接使用增强for和用迭代器方式（iterator）是不一样的，后者可以直接修改、删除原数据，但增强for是引用了一个第三方变量进行遍历，只适合单纯遍历。

#### 1.3、但是**iterator**是自动取下一个，如果需要倒着遍历怎么办？

List集合可以使用迭代器倒着遍历，ListIterator有previous()方法和hasprevious()方法，可以自动指向并取出上一个元素。Set集合不能用迭代器倒着遍历，但可以根据它的大小顺序倒着取出。

#### 1.4、使用**foreach**、**iterator**、**for**在有什么区别？效率上哪个更高？

区别上：

普通for循环一般用来处理比较简单的有序的，可预知大小的集合或数组.

foreach可用于遍历任何集合或数组，而且操作简单易懂，唯一的不好就是需要了解集合内部类型，它的底层有函数式编程注解 @FunctionalInterface，也就是说它可以进行Lamda形式简写。

iterator是最强大的，他可以随时修改或者删除集合内部的元素，并且是在不需要知道元素和集合的类 型的情况下进行的，当你需要对不同的容器实现同样的遍历方式时，迭代器是最好的选择！

至于增强for和iterator其实是一样的，增强for编译后的.class文件中，就是iterator，所以二者除了写法是用第三方参数来表示，效率上没有任何区别。

效率上：

这个需要多方考虑，比如普通for循环用在数组是遍历最快的，它是直接获取数据，但普通for不能用在不知道长度的集合中，这就需要用iterator或者foreach，相对来说，iterator效率会高于foreach，因为foreach在访问过程中产生一个额外的Enumerator对象，这个对象会进行版本检查处理，所以它是线安全的。

对于ArrayList来说，它是通过一个数组实现的，可以随机存取；但是LinkedList是通过链表实现的，当要遍历依个取出时，for循环时要取的每个元素都必须从头开始遍历，而iterator遍历则从头开始，边遍历边取，取完只需要一次遍历，所以for循环需要的时间远远超过for循环。  对于数组来说，for和foreach循环效率差不多，但是对于链表来说，for循环效率明显比foreach低。

#### 2、你了解ArrayList和LinkedList的底层原理吗？

首先，List集合是有序集合，即存取有序，List集合的特点是存取顺序一致，存储元素可重复，都有索引。

ArrayList的底层是数组，一个索引对应一个元素，所以查询速度快；但是在增删时，需要调整整组数据的移动，所以增删较慢。

而LinkedList的底层是双向链表，每次查询时都要从两头开始查询（离头近就从头查，离尾近就从尾查），所以查询较慢；但是增删时，只需要将链表头结点和尾结点指向新插入的结点即可，所以增删速度较快。

但如果是新增的数据量较大的情况下，ArrayList的新增效率反面比LinkedList的效率更高。因为ArrayListr底层数组的扩容是1.5倍，数据量越大，扩容的速度就越快，而链表仍需一个个断开链接和重续新链接。

最后，jdk8版还对ArrayList做了懒加载优化，在之前是构造ArrayList时就默认开辟10个空间，jdk8之后变成了只有放入第1个元素时，才会开辟10个空间。

#### 3、你了解TreeSet的底层原理吗？分别讲一下Set集合和Tree这种数据结构。

 Set集合的特点是必须排序，没有索引，不可重复。Set集合分为HashSet和TreeSet，HashSet底层使用的是哈希表，它的排序规则是按照底Hash函数决定的，无法人为设置；而TreeSet的底层则是使用红黑树，可以使用自然排序（自定义类中实现Comparable接口，重写CompareTo方法）或比较器排序（在创建TreeSet对象创建一个Comparator的匿名内部类，并重写Compare方法），扩容时通过结点链接。

红黑树又叫平衡二叉B树，它的结构模型十分有趣，红黑树不是绝对平衡，而是有着自己的平衡方式，为了保证数据高效查询，红黑树所有结点排成一条线后一定是左小右大的，并且在插入新的结点时，会通过左旋和右旋的方式来平衡二叉数。

红黑树的5个平衡规则：1、节点非红即黑2、根节点必须为黑3、叶节点必须为黑4、不能双红5、任何一个节点到其任一的叶节点的简单路径上，黑色节点的数量相同。

红黑树插入结点时的变化：（默认添加红节点）

1、插入红节点在根节点时，变黑

2、插入红节点在非根节点，父节点为黑时，不变

3、插入红节点在非根节点，父节点为红，叔节点为红时：父节点和叔节点都变黑，祖父节点变红（如果祖父节点是根结点，仍黑）

4、插入红节点在非根节点，父节点为红，叔节点为黑时：爷节点变黑，祖父节点变红（根仍黑），并以祖父节点为支点旋转。

**3.1****、TreeSet****使用Iterator****遍历的过程是怎么样的？**

因为TreeSet是按大小排序的，所以会根据从左往右，从下往上的顺序打印。

**4****、****List****集合是线程不安全的，你是怎么使用****List****集合的呢？** 

使用Collections集合工具类，对集合进行同步处理：

 List<String> list = Collections.synchronizedList(new ArrayList<>()); 

但是在多线程开发中，对其进行遍历，需要添加 synchronized 关键字，因为List的 add、index 等方法中都是带有synchronized 关键字，但是在 iterator 中没有synchronized 关键字。

**4.1****、****Conllection****和****Conllections****的区别是什么？**

Conllection是一个单列集合的接口，Collections是一个操作集合的工作类，两者本质就不一样。

**5****、你了解****HashMap****的底层实现原理吗？**

HashMap的底层是Hash表结构，元素的排列是根据哈希算法和哈希函数排序的，且不可重复。

JDK8以前，Hash表的底层是【数组】+【链表】

JDK８及之后，变成了【数组】+【链表】+【红黑树】

存入新键值对时，如果出现哈希冲突，会先判断键是否相同，如果键相同，会比较值，值相同则不放入，值不同则修改原值；如果键不相同，则会以链表形式挂下来，并且1.7版本中是头插法，1.8版本是尾插法。

**5.1****、什么是哈希冲突？**

哈希冲突就是两个元素在通过哈希函数后，得到的角标是相同的，在同一个哈希槽中。哈希冲突的四种解决思路分别是：重哈希法，开放地址法，建立公共溢出，链地址法。

**5.2****、****HashMap****的扩容机制是怎么样的？它什么时候会转化为红黑树？**

Hash表中数组的分手手动初始化，和自动初始化，自动初初始会在第一次插入元素时开辟空间，默认长度为16，扩容因子为0.75，每次扩容量为自身的2倍长度，扩容之后存入数组的新索引位置就会改变。手动初始化的话，可以在创建对象时自定义初始数组长度，但HashMap不一定会自主设置的数值初始化数组，而按2的n次方创建。

HashMap1.7版本的的扩容时机是先判断是否达到阈值，达到先扩容，再添加元素，并且采用的是头插法，也就是旧元素挂在新元素下。

而HashMap1.8的扩容时机是先添加元素是否达到阈值，达到直接扩容，且使用的是尾插法，即新元素挂在旧元素下面。

初始化后，当存入新的键值对时，会先判断数组长度是否大于64，再判断链表元素是否大于等于8时，如果两者都成立，链表会自动转换成红黑树，如果数组小于64，会从第9个开始先扩容，直到数组大于等于64时，链表长度再增加，就会转为红黑树。

细节：

在添加第一个元素的时候是直接添加进数组的，而不会进入到红黑树转化的判断的，所以里面的binCount并没有创建。添加第二元素并发生了哈希冲突时，才进入红黑树转化的判断，同时初始化binCount=0，它判断的是binCount>=7，也就是0至7，有8个元素时，再加上没有进行判断的1个元素，即第9个元素时，才会转化为红黑树。

**5.2.1****、为什么要转为红黑树呢？**

链表取一个数需要遍历链表，而红黑树相对效率要高。

**5.2.2****、为什么不直接使用红黑树呢？**

HashMap源码中有相关描述： “因为树节点的大小是链表节点大小的两倍，所以只有在容器中包含足够的节点保证使用才用它”，显然尽管转为树使得查找的速度更快，但是在节点数比较小的时候，此时对于红黑树来说内存上的劣势会超过查找等操作的优势，自然使用链表更加好，但是在节点数比较多的时候，综合考虑，红黑树比链表要好。

**5.2.3****、为什么转为红黑树的条件是8****而不是第9****第10****个呢？**

源码中有对这个进行计算，正常的随机哈希码下，哈希冲突多到超过8个的概率不到千万分之一，几乎可以忽略不计了，再往后调整并没有很大意义。

如果哈希冲突有那么多，说明极大可能是人为设置，故意制造哈希冲突导致，这时候就转为化红黑树，来保证查询效率。

**5.2.3.1****、那什么时候退出红黑树呢？**

当哈希冲突个数从第8个变到第6个时，红黑树转化为链表。

**5.2.3.1****、6****与8****之间的第7****个冲突时，会是什么状态？**

分情况看。8退6，是红黑树转链表，6进8，是链表转红黑树，中间的7是防止频繁变动做的一个预留位，如果是8退6，中间的7就是红黑树；如果是6进8，中间的7就是链表。

**5.2.4****、为什么1.7****是头插法，1.8****是尾插法？**

1.7版本使用头插法是因为头插法是操作速度最快的，找到数组位置就直接找到插入位置了，但这样插入方法在并发场景下会因为多个线程同时扩容出现循环列表，也就是Hashmap的死锁问题。

1.8版本加入了红黑树来优化哈希桶中的遍历效率，相比头插法而言，尾插法在操作额外的遍历消耗（指遍历哈希桶）已经小很多，也可以避免之前的循环列表问题，同时如果已经变成红黑树了，也不能再用头插法了，而是按红黑树自己的规则排列了。

**5.2.4.1****、如果是头插法，怎么才能获取之前的旧元素呢？**

因为1.7版本的头插法，是新元素在上面，旧元素挂新元素后面，所以新元素始终是在数组上的，可以通过在对象上重写toString方法，加上对象的HashCode值，这样只要打印出来相同的HashCode说明发生了哈希冲突，这时候只需要遍历即可，要取哪个就指定那个HashCode，相同就取出，而上一个老元素就是第二个获取的元素。

**5.2.4.2****、什么是HashMap****双链循环/****死锁？**

双链循环是JDK1.7及更早的版本之前才有的问题。在多线程扩容的情况下，一个线程执行到一半，还未扩容，而另一个线程却抢走先行扩容了，这时候可能出现第一个线程的元素与第二个线程中的元素相互引用的情况，相互引用就会造成死锁。

比如一个数线长度为4，有两个数，一个为2，一个为10，那么这两个数都会在索引2上形成哈希桶结构，此时进行扩容，本来在新数组中是2指向10的，结果但之前那个前程正好断在10指向新数组的中间，这就会导至10又重新指向2，最终导while判断中的e永远不会等于null，造成死循环。

JDK1.8版本避免了双链循环，但不是完全避免，看过一些测试文章，红黑树之间也可能出现死循环，只是比较1.7版本，几率降低。

**5.2.5****、为什么1.7****是先扩容再添加，1.8****却改成先添加再扩容？**

因为1.7版本中的扩容机制有两个条件：

1、 存放新值的时候当前已有元素的个数必须大于等于阈值（数组长度*0.75）。

2、 存放新值的时候当前存放数据发生hash碰撞（当前key计算的hash值换算出来的数组下标位置已经存在值）

要满足以上两个条件，很可能出现数组16个元素都填满的情况（正好无碰撞填满数组），如果是先添加再扩容，就会导致第17个元素必然发生哈希冲突，这不是我们要的结果，我们要的是尽量减少哈希冲突，所以需要先扩容，再放入元素。

而在1.8版本中，扩容的条件改成了实际数量大于等于阈值就扩容，所以允许了先添加再扩容这种情况，也可能是作者认为没有1.7那么强制性需要先扩容了，为了更符合思考逻辑，改成了先添加，再扩容。

**5.2.6****、1.8****版本是否完全避免死循环问题？**

不能。1.8版本中引进了红黑树，可以降低死循环出现的机率，但不能完全避免，红黑树之间也可能出现死循环。

**5.3****、****HashMap****为什么数组长度始终是****2****的****n****次方？**

在HashMap的底层对于数组的操作其实是（n-1）&hash，当数组的长度为2的n次时，减1转为二进制后，他被任何数字&上都不会超过这个数字，比如数组长度为8，减1后为7，那么它的数组长度就是0-7，共8个，即元素可以在这个数组上全部排满，而如果是奇数，或者不是2的n次的偶数，一定会有一个二进制为0，也就是无论另一个数是什么，都不会被存入数组，会浪费掉的位置。

**5.4****、****HashMap****的扩容为每次是原来的****2****倍？**

首先，HashMap的初始化的数组长度一定是2的n次的，每次扩容仍是原来的2倍的话，就不会破坏这个规律，每次扩容后，原数据都会进行数据迁移，根据二进制的计算，扩容后数据要么在原来位置，要么在【原来位置+扩容长度】，这样就不需要重新hash，效率上更高。

**5.4****、****HashMap****是怎么让存取效率最高的？**

如果元素都是均匀存储在数据的角标位而不产生冲突，就是最好的。

1、尽可能少的产生hash冲突

hash函数计算出来的角标尽可能做到均匀。

2、确实产生了hash冲突——数据结构来解决

 数组+链表+红黑树

3、HashMap的底层通过扰动函数（即高低位运算）来让数组更均匀的被分配。

 (h = key.hashCode()) ^ (h >>> 16)

扰动函数将自己的前即低16位与高16位运算，可以让数组在65535（int）范围内更均匀的分配。高低位运算：16刚好在32位的中间，前16位和自己的后16位对比，然后再把对比值和数组的对比。

**5.5****、多线程下的****HashMap****线程安全吗？为什么？**

HashMap本身就是不安全的，多线程下，在添加元素时容易出现数据覆盖情况而丢失数据，也可能在扩容时，迁移数据出现数据覆盖情况而丢失数据。

**6****、你了解****Hashtable****吗？它跟****HashMap****有什么区别？**

HashMap是线程不安全的（多线程环境下会出问题）；

Hashtable是线程安全的（但效率低下）；

Hashtable底层和哈希表一样，扩容因子是0.75，扩容倍率是2倍。

Hashtable一次只能执行一个线程（全表加锁），采取悲观锁（增善改的方法上都加了synchronized）保证了线程安全。

**7****、说一说****ConcurrentHashMap****，****JDK7****版本跟****JDK8****版本有什么不同？**

**ConcurrentHashMap1.7****版本：**

**创建对象**

1、默认创建一个长度16，加载因子为0.75的大数组，但这个大数组一但创建无法扩容，所以加载因子是给小数组用的。

2、还会创建一个长度为2的小数组，把地址值赋值给0索引处。其他索引位置的元素均为null。

 **插入元素**

第一次插入新元素时，会根据键的哈希值来计算出在大数组中应存入的位置。

· 如果为null，则按照模板创建小数组，大数组只用来存放地址值。

o 创建完毕，会进行二次哈希，计算出在小数组中应存入的位置。

o 直接存入。

· 如果不为null，就会根据记录的地址值找到小数组。

o 二次哈希，计算出在小数组中应存入的位置。

o 如果需要扩容，则先将小数组扩容2倍。

o 如果不需要扩容，则判断小数组的这个位置有没有元素。

§ 如果没有元素，则直接存。

§ 如果有元素，就会调用equals方法，比较属性值

· 如果equals为true，相同则不存；

· 如果equals为false，新元素替换老元素，老元素挂在新元素下面，形成哈希桶结构（链表）。

**线程安全**

1、用synchronized同步代码块形式保证线程安全，锁住大数组的一个地址值连同它的小数组。

2、最多同时访问16个线程，因为大数组只有16个哈希槽。

**ConcurrentHashMap1.8****版本：**

区别1.7：

· 底层结构改变：

哈希表（数组会扩容）——【数组】+【链表】+【红黑树】

1.7是旧元素挂新元素下面（旧挂新——头插法）；1.8是新元素挂在旧元素下面（新挂旧——尾插法）！

· 线程安全机制改变：结合CAS机制+synchronized同步代码块形式保证线程安全。

如果该索引为null，则利用cas算法，将本结点添加到数组中。（第一次添加用CAS算法）

如果该索引不为null，则利用volatile关键字获得当前位置最新的结点地址，新元素挂在旧元素下面。（因为1.8后有了红黑树，会自动进行排序调整，再调整链表头就浪费资源了，而旧版本需要后进先出）

（红黑树转化条件见HashMap底层）

有元素后，再对该元素进行操作时，会给头结点（第一个元素）做为锁对象，加上synchronized同步代码块（锁对象的方式），保证线程安全。

· 加载机制改变：懒加载——第一次添加元素时初始化数组。（添加元素时，判断数组是否为空，或者长度为0，如果是，就初始化数组）